#!/usr/bin/python3
#hardware GPL3
#Copyright (C) 2021 David Hamner

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program. If not, see <http://www.gnu.org/licenses/>.

#This program gathers helpful logs for debuging issues and removes hardware IDs and user data.
#This is an open reimplementation of a supportconfig like project.

#sudo apt install python3-pygame python3-pyte
import subprocess
import random
import string
import os
import pygame
from bash_hook import *

script_path = os.path.dirname(os.path.realpath(__file__))
chroot_path = os.path.expanduser("~/.poodillion_root")

display_width = int(720/2)
display_height = int(860/2)
clock = pygame.time.Clock()

startup_CMD = f"pkexec {script_path}/bin/run"
prompt_size = 80 #I can't seem to change this in pyte
prompt_raw = "poodillion@???:~$ "
fount_size = int(display_width/prompt_size)#(prompt_size - len(prompt_raw))
fount_size = fount_size * 4
npc_imges = {}
total_life = 100
player_life = total_life
dynamic_fs_levels = {}
init_text = "Enter your password in the pkexec window\nThen press any key to continue..."
#                   Text:Time in ticks
display_txt = {init_text:50}

#Needed for the Librem 5!
#X11_DISPLAY = ":0"
#os.environ['DISPLAY'] = X11_DISPLAY


def button(msgs,x,y,w,h,ic,action=None):
    mouse = pygame.mouse.get_pos()
    click = pygame.mouse.get_pressed()
    #print(click)
    pygame.draw.rect(gameDisplay, ic,(x,y,w,h))
    if x+w > mouse[0] > x and y+h > mouse[1] > y:
        if click[0] == 1 and action != None:
            action()         
    
    offset = 1
    msgs = msgs.split("\n")
    total_msgs = len(msgs)
    dist_apart = int(h / total_msgs)
    for msg in msgs:
        smallText = pygame.font.SysFont("comicsansms",20)
        textSurf, textRect = text_objects(msg, smallText)
        if total_msgs == 1:
            textRect.center = ( (x+int(textRect.width/2) + 5), (y+int(h/2)) )
        else:
            textRect.center = ( (x+int(textRect.width/2) + 5), (y+(dist_apart*offset) - 10) )
            offset += 1
        gameDisplay.blit(textSurf, textRect)


def value_bar(x,y,value, from_right=True, size=10, px_multiplayer=1.6, hide_text=False, title=""):
    value_txt = f"{title}:{value}"
    
    #set bar size to 160 px (1.6 times 100%)
    value *= px_multiplayer
    
    if from_right:
        #Grow from right
        x = x - value
    
    pygame.draw.rect(gameDisplay, pygame.color.Color("black"),(x,y,value,size))
    if not hide_text:
        smallText = pygame.font.SysFont("comicsansms",15)
        textSurf, textRect = text_objects(value_txt, smallText, color="white")
        textRect.center = ( (x+int(value/2)), (y+int(size/2)) )
        gameDisplay.blit(textSurf, textRect)

def quit():
    pygame.quit()
    exit()

def reset_clip():
    global selected_crop
    global pos1
    global pos2
    selected_crop = False
    pos1 = ()
    pos2 = ()

def text_objects(text, font, color="Black"):
    textSurface = font.render(text, True, pygame.color.Color(color))
    return textSurface, textSurface.get_rect()

def draw_prompt(prompt_text):
    global text_font
    global background_color
    #clear
    pygame.draw.rect(gameDisplay,background_color,(0,display_height-15,display_width,15))
    #Draw
    TextRect = text_font.render(prompt_text, True, (255, 255, 255))
    gameDisplay.blit(TextRect, (0,display_height-12))

def action_cd(new_xy, exit_right=True, reset_player_pos=True):
    global gameDisplay
    global player_xy
    global player_image
    num_frames = 30
    fps = 30
    player_img_height = 90
    player_start = copy.deepcopy(player_xy)
    space_to_move_right = (display_width - player_xy[0])/num_frames
    space_to_move_up_down = ((new_xy-player_img_height/2) - player_xy[1])/num_frames
    if not exit_right:
        space_to_move_right = space_to_move_right * -1
        space_to_move_up_down = 0
        num_frames = 10
    for i in range(0,num_frames):
        #clear old player
        pygame.draw.rect(gameDisplay,(255,255,255),(player_xy[0],player_xy[1],50,90))
        player_xy[0] = int(player_xy[0] + space_to_move_right)
        player_xy[1] = int(player_xy[1] + space_to_move_up_down)
        gameDisplay.blit(player_image, player_xy)
        #print(player_xy)
        pygame.display.update()
        clock.tick(fps)
    if reset_player_pos:
        player_xy = player_start

def draw_doors():
    global gameDisplay
    global PWD
    
    chroot_PWD = chroot_path + PWD
    #print(chroot_PWD)
    dirs_next_door = []
    dir_pos = {}
    door_color = {}
    try:
        files_and_dirs = os.listdir(chroot_PWD)
    except PermissionError:
        files_and_dirs = []
    for file_or_dir in files_and_dirs:
        file_or_dir = chroot_PWD + "/" + file_or_dir
        if os.path.isdir(file_or_dir):
            if not os.path.islink(file_or_dir):
                #print(file_or_dir)
                if chroot_PWD == "/":
                    short_name = f"/{file_or_dir.split(chroot_PWD)[-1]}"
                elif file_or_dir.startswith(chroot_PWD):
                    short_name = f".{file_or_dir.split(chroot_PWD)[-1]}"
                
                else:
                    short_name = file_or_dir
                dirs_next_door.append(short_name)
    
    #dirs_next_door=["/home","/proc"]
    num_dir_door = len(dirs_next_door)
    #print(num_dir_door)
    
    size_on_right = display_height - 60
    space_per_door = int(size_on_right/(num_dir_door +1))
    #TODO remove this and fix the math
    if num_dir_door == 1:
        offset = -10
    elif num_dir_door > 20:
        offset = 40
    elif num_dir_door > 4:
        offset = 15
    else:
        offset = 0
        
    for i in range(1,num_dir_door+1):
        pos = int((space_per_door*i) + offset)
        dir_pos[dirs_next_door[i-1]] = pos + int(space_per_door/4)
        chroot_sub_path = f"{PWD}/{dirs_next_door[i-1].strip('./')}".replace("//","/")
        full_path = f"{chroot_path}{chroot_sub_path}"
        #check if we can access the folder:
        color = (255,255,255)
        if not os.access(full_path, os.X_OK):
            color = (255,50,50)
        #print(f"Hmmmm {full_path}")
        pygame.draw.rect(gameDisplay,color,(display_width-15,pos,15,int(space_per_door/2)))
        #print(pos)
    for file_name in dir_pos:
        
        #if file_name.startswith(PWD):
            #file_text = f".{file_name.split(PWD)[-1]}"
        #else:
            #file_text = file_name
        TextRect = text_font.render(file_name, True, (0, 0, 0))
        pos = dir_pos[file_name]
        gameDisplay.blit(TextRect, (display_width - (len(file_name)*6),pos - 6))
    return(dir_pos)


def process_NPC_line(line):
    global script_path
    global npc_imges
    global game_actors
    global chroot_path
    global PWD
    
    chroot_PWD = chroot_path + PWD
    
    raw_data = line.split(":")
    #Example data
    ##   when:          img:             name:    % action:damage:    % drops
    #on_enter: frog_guy.png:              bob: 100% walk 3:     1: 100% na
    #every 40: frog_guy.png: son_of_bob_$RAND: 100% walk 3:     1:  50% 5HP
    when = raw_data[0].strip()
    name = raw_data[2].strip()
    life_file = ""
    if when == "on_enter":
        life_file = f"{chroot_PWD}/{name}"
        with open(life_file, 'w') as fh:
            pass
        when = "active"
    img = f"{script_path}/img/{raw_data[1].strip()}"
    npc_imges[img] = pygame.image.load(img).convert()
    
    
    action_raw = raw_data[3].strip().split(' ')
    #Example data
    #100% walk 3
    change_action = action_raw[0].strip("%")
    action = f"{action_raw[1]} {action_raw[2]}"
    
    damage = int(raw_data[4].strip())
    
    drop_raw = raw_data[5].strip().split(' ')
    #Example data
    #["50%", "5HP"]
    #["100%", "na"]
    chance_drop = drop_raw[0].strip("%")
    drops = drop_raw[1]
    
    start_pos = [display_width-50,int(display_height/(int(random.randint(1,200)/100)+2))]
    game_actors[name] = {"when":when,
                            "img":img,
                            "name":name,
                            "action_chance":change_action,
                            "action":action,
                            "damage":damage,
                            "drop_chance":chance_drop,
                            "drops":drops,
                            "pos":start_pos,
                            "lastPos": copy.deepcopy(start_pos),
                            "life_file": life_file}

def load_spawner(PWD):
    global chroot_path
    global game_actors
    global npc_imges
    
    chroot_PWD = chroot_path + PWD
    possible_spawn_file = f"{chroot_PWD}/.spawner"
    
    #Clear out any old spawner data
    game_actors = {}
    
    #If we have a spawner load it
    if os.path.isfile(possible_spawn_file):
        with open(possible_spawn_file) as fh:
            for line in fh.readlines():
                if line.startswith("#"):
                    continue
                if line.startswith("on_enter") or line.startswith("every"):
                    process_NPC_line(line)
                    
        

def draw_npc():
    global game_actors
    global gameDisplay
    global npc_imges
    
    for player_name in game_actors:
        status = game_actors[player_name]['when']
        if status == "active":
            #print("draw NPC")
            #Clear old
            img = game_actors[player_name]['img']
            img = npc_imges[img]
            pos = game_actors[player_name]['lastPos']
            pygame.draw.rect(gameDisplay,(255,255,255),(pos[0],pos[1],img.get_width(),img.get_height()))
            #Draw new
            pos = game_actors[player_name]['pos']
            gameDisplay.blit(img, pos)
            

def did_it_happen(chance):
    chance = int(chance)
    rand_int = random.randint(1,100)
    if rand_int <= chance:
        return(True)
    return(False)

def FIRE(pos):
    global gameDisplay
    global player_xy
    fire_pos = [player_xy[0] + 30,player_xy[1] + 10]
    pygame.draw.line(gameDisplay, (255,0,0), (fire_pos[0], fire_pos[1]), (pos[0], pos[1]), 4)
    pygame.display.update()
    
    clock.tick(6)
    #Clear line
    pygame.draw.line(gameDisplay, (255,255,255), (fire_pos[0], fire_pos[1]), (pos[0], pos[1]), 4)

def unlock_door(dir_name):
    os.chmod(dir_name, 0o777)

def lock_away(dir_name):
    os.chmod(dir_name, 0o222)
    
def update_dynamic_fs():
    global dynamic_fs_levels
    global PWD
    global chroot_path
    global level_data
    global current_level_base
    
    for spawn in dynamic_fs_levels:
        level_data = dynamic_fs_levels[spawn]
        first_dir_path = level_data['spawn']
        max_depth = int(level_data['depth'])
        num_rooms = int(level_data['rooms'])
        all_rooms_npc = level_data['all_rooms_npc']
        #get locked rooms
        locked_rooms = level_data["locked"]
        #print(f"This data: {first_dir_path}")
        start_dir = os.path.dirname(first_dir_path)
        #print(f"This data: {start_dir}")
        if PWD == start_dir:
            #check our start folder is here
            current_level_base = first_dir_path
            full_path = f"{chroot_path}{first_dir_path}"
            if not os.path.isdir(full_path):
                os.mkdir(full_path)
        
        #This is a sub path!
        elif first_dir_path in PWD:
            current_level_base = first_dir_path
            short_path = PWD.split(first_dir_path)[-1]
            depth = len(short_path.split("/"))-1
            
            #setup NPCs
            for npc_line in all_rooms_npc:
                print(f"Processng NPC line: {npc_line}")
                process_NPC_line(npc_line)
            if short_path in level_data:
                for npc_line in level_data[short_path]:
                    process_NPC_line(npc_line)
            
            #Build new rooms
            if depth < max_depth:
                #create new rooms if needed
                for room_index in range(1,num_rooms+1):
                    sub_room_name = f"{short_path}/{room_index}"
                    full_path = f"{chroot_path}{first_dir_path}{sub_room_name}"
                    if not os.path.isdir(full_path):
                        os.mkdir(full_path)
                        #print(full_path)
                        #print(short_path)
                        #print(f"HMMM: {sub_room_name} in {locked_rooms}")
                        if sub_room_name in locked_rooms:
                            print(f"Lock away {full_path}")
                            lock_away(full_path)
            print(f"TODO Yo {depth}")
            print(short_path)
        print(PWD)
        #for level_item in level_data:
            #print(f"{level_item}:{level_data[level_item]}")

def update_game():
    global gameDisplay
    global player_xy
    global game_tick
    global PWD
    global chroot_path
    global player_life
    global game_actors
    global current_level_base
    global display_txt
    
    #print(game_actors)
    new_NPCs = {}
    chroot_PWD = chroot_path + PWD
    for player_name in game_actors:
        status = game_actors[player_name]['when']
        drop_chance = game_actors[player_name]['drop_chance']
        drops = game_actors[player_name]['drops']
        damage = game_actors[player_name]['damage']
        if status.startswith("every"):
            #print(status)
            start_on = int(status.split(" ")[-1])
            #print(start_on)
            #print(game_tick)
            if game_tick % start_on == 0:
                print("Need to added active!")
                new_npc = copy.deepcopy(game_actors[player_name])
                new_npc_name = new_npc['name']
                if "$RAND" in new_npc_name:
                    rand_string = ''.join(random.choices(string.ascii_uppercase + string.digits, k = 7))
                    new_npc_name = new_npc_name.replace("$RAND", rand_string)
                
                new_npc['name'] = new_npc_name
                life_file = f"{chroot_PWD}/{new_npc_name}"
                print(life_file)
                with open(life_file, 'w') as fh:
                    pass
                new_npc['when'] = "active"
                new_npc['life_file'] = life_file

                new_NPCs[new_npc_name] = new_npc

                #game_actors[new_npc_name] = new_npc
                #print(game_actors)
                
        if status == "active":
            #print("Active NPC")
            life_file = game_actors[player_name]['life_file']
            if not os.path.isfile(life_file):
                print(f"Killed {life_file}")
                if did_it_happen(drop_chance):
                    #examples drops
                    #5HP
                    #unlock/1
                    if drops.endswith("HP"):
                        life_drop = int(drops.strip("HP"))
                        player_life = player_life + life_drop
                        print(f"Player life: {player_life}")
                    if drops.startswith("unlock"):
                        short_name = drops.split("unlock")[-1]
                        msg = f"A door has Opened!\nFind your way to:\n  {current_level_base}{short_name}"
                        display_txt = {msg:50}
                        full_path = f"{chroot_path}{current_level_base}{short_name}"
                        print(f"Unlock: {full_path}")
                        unlock_door(full_path)
                
                #Setup needed data
                img = game_actors[player_name]['img']
                img = npc_imges[img]
                pos = game_actors[player_name]['lastPos']
                
                #Draw laser
                pygame.draw.rect(gameDisplay,(255,0,0),(pos[0],pos[1],img.get_width(),img.get_height()))
                FIRE(pos)
                
                #clear player
                pygame.draw.rect(gameDisplay,(255,255,255),(pos[0],pos[1],img.get_width(),img.get_height()))
                game_actors[player_name]['when'] = "DEAD"
                continue
            pos = game_actors[player_name]['pos']
            action = game_actors[player_name]['action']
            action_chance = game_actors[player_name]['action_chance']
            if did_it_happen(action_chance):
                if action.startswith("walk"):
                    #check if we are hit
                    if (pos[0] - player_xy[0]) < 25 and (pos[1] - player_xy[1]) < 25:
                        player_life = player_life - damage
                        if player_life <= 0:
                            #Reset
                            print("Player Dead!")
                            text = "Better luck next time!"
                            notify(text)
                            quit()
                        print("Hit")
                        continue
                    speed = int(action.split(" ")[-1])
                    x_delta = pos[0] - player_xy[0]
                    y_delta = pos[1] - player_xy[1]
                    
                    total_delta = x_delta + y_delta
                    x_speed = (speed/total_delta)*x_delta
                    y_speed = (speed/total_delta)*y_delta
                    
                    game_actors[player_name]['lastPos'] = copy.deepcopy(game_actors[player_name]['pos'])
                    game_actors[player_name]['pos'][0] -= x_speed
                    game_actors[player_name]['pos'][1] -= y_speed
                    #print(f"Moving with speed of {speed} {x_speed} {y_speed}")
                    
            #print(pos)
    #add new NPCs outside of above eath loop
    for new_npc_name in new_NPCs:
        game_actors[new_npc_name] = new_NPCs[new_npc_name]
def main_interface():
    #Globals needed by the reset call
    global selected_crop
    global text_font
    global background_color
    global player_image
    global player_xy
    global PWD
    global game_actors
    global game_tick
    global player_life
    global display_txt
    global redraw_forced
    
    running = True
    
    background_color = pygame.color.Color(25,25,25)
    prompt_text = prompt_raw
    std_out = ""
    num_dir_door = 0
    player_xy = [50, int(display_height/2)-45]
    player_image = pygame.image.load(f"{script_path}/img/player.png").convert()
    dir_pos = {}
    game_actors = {}
    game_tick = 1
    redraw_forced = False
    #img = pygame.image.load(image_file_to_display)
    #img = pygame.transform.scale(img, (display_width, display_height))
    

    PWD = get_PWD()
    rendered_path = None

    while running:
        #look for new events
        for event in pygame.event.get():
            #print(event)
            if event.type == pygame.QUIT:
                pygame.quit()
                quit()
            if event.type == pygame.KEYDOWN:
                key = event.unicode
                composit_process(key)
                #print(key)
                #Update prompt and std_out
                time.sleep(0.01)
                std_raw = get_tty_out()
                prompt_text = std_raw[0]
                std_out = std_raw[1]
                #print(std_out)
                #Update PWD
                PWD = get_PWD()
                #print(PWD)
                draw_prompt(prompt_text)
        

        #redraw room
        if (rendered_path != PWD and PWD != "Loading...") or redraw_forced:
            
            #Play cd action
            if not redraw_forced:
                short_pwd = f"./{PWD.split('/')[-1]}"
                if short_pwd in dir_pos:
                    action_cd(dir_pos[short_pwd])
                elif rendered_path != None:
                    action_cd(player_xy[0], exit_right=False)
            
            #Update rendered path
            rendered_path = PWD
            
            #Clear
            gameDisplay.fill(background_color)
            
            #draw main room
            pygame.draw.rect(gameDisplay,(255,255,255),(15,15,display_width-30,display_height-30))
            draw_prompt(prompt_text)
            
            #draw player
            gameDisplay.blit(player_image, player_xy)
            
            #Draw ../ door
            if PWD != "/":
                pos = int(display_height/2)
                pygame.draw.rect(gameDisplay,(255,255,255),(0,pos,15,30))
                TextRect = text_font.render("../", True, (0, 0, 0))
                gameDisplay.blit(TextRect,(10,pos+8))
            
            
            #Don't update logic if redraw if forced
            if not redraw_forced:
                #load spawner
                load_spawner(PWD)
                
                #Update dynamic_fs
                update_dynamic_fs()
            else:
                redraw_forced = False
            #Draw dirs in room as doors
            dir_pos = draw_doors()
        
        #Draw life bar:
        #clear old
        pygame.draw.rect(gameDisplay,(255,255,255),(20,20,100,10))
        #Draw new
        value_bar(20,20, player_life, from_right=False, size=10, px_multiplayer=1, hide_text=False, title="Life")
        
        #Update display text:
        for message in display_txt:
            ticks_left = display_txt[message]
            display_txt[message] = display_txt[message] - 1
            if ticks_left <= 0:
                del(display_txt[message])
                redraw_forced = True
                break
            else:
                #clear
                pos = [25,45]
                for line in message.split("\n"):
                    pygame.draw.rect(gameDisplay,background_color,(pos[0]-5,pos[1]-5,display_width -pos[0]*2 ,20))
                    #Draw
                    TextRect = text_font.render(line, True, (255, 255, 255))
                    gameDisplay.blit(TextRect, (pos[0],pos[1]))
                    print(f"{message}:{ticks_left}")
                    pos[1] += 15
        #print(display_txt)
        #read_clip_button_text = prompt_text
        #read_clip_button_pos = [display_width- 115,0]
        #read_clip_button_size = [105,30]
        #blue_color = pygame.color.Color("blue")
        #button(read_clip_button_text,read_clip_button_pos[0],read_clip_button_pos[1],read_clip_button_size[0],read_clip_button_size[1],blue_color,blank)
    
        #button("",sidebar_pos[0],sidebar_pos[1],20,300,lockdown_color,quit)
        
        
        #Draw keyboard info
        #keyboard_text = "(EN) Keybaord"
        #keyboard_pos = [display_width- 100,590]
        #keyboard_size = [int(display_width/3.5),70]
        #button(keyboard_text,keyboard_pos[0],keyboard_pos[1],keyboard_size[0],keyboard_size[1],color,quit)
        
        #############################################################################################
        #Draw is powered bar
        #############################################################################################
        #power_bar_pos = [display_width/2-13,577]
        #button("",power_bar_pos[0],power_bar_pos[1],25,75,powered_bar_color,quit)
        #Update NPC
        update_game()
        #Draw NPC
        draw_npc()
        if game_tick > 1000:
            game_tick = 2
        else:
            game_tick = game_tick + 1
        #print(game_tick)
        #print("Tick")
        pygame.display.update()
        clock.tick(6)

#place holder button function
def blank():
    print("Blank")
    return()

def cmd_run(command):
    command = command.split()
    try:
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        raw_data =  result.stdout.decode()
        raw_data += result.stderr.decode()
    except FileNotFoundError:
        raw_data = "Command Not Found"
    
    return(raw_data)

def cmd_live(command):
    process = subprocess.Popen(command, stdout=subprocess.PIPE)
    for line in iter(process.stdout.readline, b''):
        yield(line)
        
def notify(msg):
    cmd = f"notify-send Poodillion '{msg}'"
    os.system(cmd)

#Install/build root
def run_setup():
    cmd = f"/usr/bin/pkexec '{script_path}/bin/build_root.sh'"
    msg = "Running setup for the first time... \nThis will take about 10 minutes"
    notify(msg)
    print(msg)
    os.system(cmd)


def load_dynamic():
    global dynamic_fs_levels
    global script_path
    
    path = f'{script_path}/dynamic_fs/'

    files = os.listdir(path)
    
    level_files = []
    for file_name in files:
        level_path = f"{path}{file_name}"
        #print(level_path)
        level_files.append(level_path)
    

    for level_path in level_files:
        level_data = {}
        level_data["locked"] = []
        level_data["all_rooms_npc"] = []
        raw_data = open(level_path).readlines()
        name = ""
        for level_line in raw_data:
            if level_line.startswith("#"):
                continue
            for easy_load_team in ["spawn", "rooms", "depth"]:
                if level_line.startswith(easy_load_team):
                    level_data[easy_load_team] = level_line.split(":")[-1].strip()
            if level_line.startswith("locked:"):
                level_data["locked"].append(level_line.split(":")[-1].strip())
            if level_line.startswith("all_rooms:"):
                data = level_line.split("all_rooms:")[-1].strip()
                level_data["all_rooms_npc"].append(data)
            if level_line.startswith("room:"):
                data = level_line.split(":")
                room_path = data[1]
                spawn_data = level_line.split(f"room:{room_path}:")[-1].strip()
                if room_path not in level_data:
                    level_data[room_path] = [spawn_data]
                else:
                    level_data[room_path].append(data)
        
        name = level_data["spawn"]
        dynamic_fs_levels[name] = level_data
        
    
    
###############################################
#Load in fs level data effects dynamic_fs_levels
load_dynamic()
#for spawn in dynamic_fs_levels:
#    level_data = dynamic_fs_levels[spawn]
#    for level_item in level_data:
#        print(f"{level_item}:{level_data[level_item]}")
#print(dynamic_fs_levels)

#Setup tty
###############################################
#Open new virt tty shell
open_tty()

def get_PWD():
    global BASH_PID
    global chroot_path
    global script_path
    path = f"{chroot_path}/game/PWD"
    if not os.path.isfile(path):
        #This should only happen if the main chroot is missing.
        print("Need to run setup script!")
        run_setup()
        
    with open(path) as fh:
        return_data  = fh.readline().strip()
    return(return_data)

def get_tty_out():
    try:
        raw_data = copy.deepcopy(output_data[target_tty])
    except RuntimeError as E:
        #retry
        print("Error reading data...")
        time.sleep(.02)
        print(E)
        return(get_tty_out())

    cmd_text = ""
    shell_prompt = ""
    for line_index in raw_data:
        line = raw_data[line_index]
        cmd_text = cmd_text + "\n"
        for col_index in line:
            char_obj = line[col_index]
            char_pos = [line_index, col_index]
            cmd_text = cmd_text + char_obj.data
    shell_prompt = cmd_text.split("\n")[-1].strip()
    std_out = cmd_text.split("\n")[:-1]
    #print(f"New shell: {cmd_text}")
    #print(cmd_text)
    #return("")
    return([shell_prompt,std_out])

#get_PWD has a check if the chroot is setup
PWD_ATM = get_PWD()
#Make sure to start in /home/poodillion
if PWD_ATM != "Loading...":
    path = f"{chroot_path}/game/PWD"
    with open(path, 'w') as fh:
        fh.write("Loading...")
###############################################
#Run Init bash comand
msg = "Poodillion needs root access to isolate itself in a systemd container."
notify(msg)
bash_run(startup_CMD, -1)
#Set prompt
cmd = f'PS1="{prompt_raw}"'
bash_run(cmd, -1)
###############################################
pygame.init()
text_font = pygame.font.SysFont("comicsansms",fount_size)
gameDisplay = pygame.display.set_mode((display_width,display_height))
main_interface()

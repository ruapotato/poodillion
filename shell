#!/usr/bin/python3
#hardware GPL3
#Copyright (C) 2021 David Hamner

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program. If not, see <http://www.gnu.org/licenses/>.

#This program gathers helpful logs for debuging issues and removes hardware IDs and user data.
#This is an open reimplementation of a supportconfig like project.

#sudo apt install python3-pygame python3-pyte
import subprocess
import random
import string
import os
import pygame
from bash_hook import *
from player_sys import *

script_path = os.path.dirname(os.path.realpath(__file__))
chroot_path = os.path.expanduser("~/.poodillion_root")

display_width = int(720/2)
display_height = int(860/2)
clock = pygame.time.Clock()

startup_CMD = f"pkexec {script_path}/bin/run"
prompt_size = 80 #I can't seem to change this in pyte
prompt_raw = "poodillion@???:~$ "
fount_size = int(display_width/prompt_size)#(prompt_size - len(prompt_raw))
fount_size = fount_size * 4
npc_imges = {}
total_life = 0
player_life = 0
total_power = 0
player_power = total_power
dynamic_fs_levels = {}
init_text = "Enter your password in the pkexec window\nThen press any key to continue..."
fps = 20
files_processed = []
#                   Text:Time in ticks
#display_txt = {init_text:50}

#Needed for the Librem 5!
#X11_DISPLAY = ":0"
#os.environ['DISPLAY'] = X11_DISPLAY


def button(msgs,x,y,w,h,ic,action=None):
    mouse = pygame.mouse.get_pos()
    click = pygame.mouse.get_pressed()
    #print(click)
    pygame.draw.rect(gameDisplay, ic,(x,y,w,h))
    if x+w > mouse[0] > x and y+h > mouse[1] > y:
        if click[0] == 1 and action != None:
            action()         
    
    offset = 1
    msgs = msgs.split("\n")
    total_msgs = len(msgs)
    dist_apart = int(h / total_msgs)
    for msg in msgs:
        smallText = pygame.font.SysFont("comicsansms",20)
        textSurf, textRect = text_objects(msg, smallText)
        if total_msgs == 1:
            textRect.center = ( (x+int(textRect.width/2) + 5), (y+int(h/2)) )
        else:
            textRect.center = ( (x+int(textRect.width/2) + 5), (y+(dist_apart*offset) - 10) )
            offset += 1
        gameDisplay.blit(textSurf, textRect)


def value_bar(x,y,value, from_right=True, size=10, px_multiplayer=1.6, hide_text=False, title=""):
    value_txt = f"{title}:{value}"
    
    #set bar size to 160 px (1.6 times 100%)
    value *= px_multiplayer
    
    if from_right:
        #Grow from right
        x = x - value
    
    pygame.draw.rect(gameDisplay, pygame.color.Color("black"),(x,y,value,size))
    if not hide_text:
        smallText = pygame.font.SysFont("comicsansms",15)
        textSurf, textRect = text_objects(value_txt, smallText, color="white")
        textRect.center = ( (x+int(value/2)), (y+int(size/2)) )
        gameDisplay.blit(textSurf, textRect)

def quit():
    pygame.quit()
    exit()

def reset_clip():
    global selected_crop
    global pos1
    global pos2
    selected_crop = False
    pos1 = ()
    pos2 = ()

def text_objects(text, font, color="Black"):
    textSurface = font.render(text, True, pygame.color.Color(color))
    return textSurface, textSurface.get_rect()

def draw_prompt(prompt_text):
    global text_font
    global background_color
    #clear
    pygame.draw.rect(gameDisplay,background_color,(0,display_height-15,display_width,15))
    #Draw
    TextRect = text_font.render(prompt_text, True, (255, 255, 255))
    gameDisplay.blit(TextRect, (0,display_height-12))

def draw_img(img, pos):
    new_pos = [pos[0] - int(img.get_width()/2), pos[1] - int(img.get_height()/2)]
    gameDisplay.blit(img, new_pos)


def clear_img(img, pos, color=(255,255,255)):
    new_pos = [pos[0] - int(img.get_width()/2), pos[1] - int(img.get_height()/2)]
    pygame.draw.rect(gameDisplay,color,(new_pos[0],new_pos[1],img.get_width(),img.get_height()))

def draw_name(text, pos, clear=False):
    global background_color
    text_size = 7
    size = len(text) * text_size
    
    #setup offset
    pos = [pos[0]-(size/2), pos[1]]
    
    if not clear:
        pygame.draw.rect(gameDisplay,background_color,(pos[0],pos[1],size,15))
        TextRect = text_font.render(text, True, (255, 255, 255))
        gameDisplay.blit(TextRect, pos)
    else:
        pygame.draw.rect(gameDisplay,(255,255,255),(pos[0],pos[1],size,15))

    
def can_move_to(test_pos, img):
    global player_image
    x, y = test_pos
    wall_size = 20
    height = img.get_height()
    width = img.get_width()
    
    if x < wall_size+(width/2) or x > display_width-wall_size-(width/2):
        return(False)
    if y < wall_size+(height/2) or y > display_height-wall_size-(height/2):
        return(False)
    return(True)

def action_cd(new_xy, reset_player_pos=True):
    global gameDisplay
    global player_xy
    global player_image
    global player_start_pos
    global player_target
    
    fps = 20
    cd_speed = 15
    while player_xy != new_xy:
        #print(f"Updateing: {player_xy} {new_xy} ")
        #clear old pos
        clear_img(player_image, player_xy)
        #pygame.draw.rect(gameDisplay,(255,0,0),(player_xy[0],player_xy[1],player_image.get_width(),player_image.get_height()))
        #setup new pos
        new_pos = get_point_along(player_xy, new_xy, cd_speed)
        player_xy = new_pos
        #redraw player
        draw_img(player_image, player_xy)
        pygame.display.update()
        clock.tick(fps)
    player_xy = copy.deepcopy(player_start_pos)
    player_target = copy.deepcopy(player_start_pos)
    
    """
    num_frames = 30
    fps = 30
    player_img_height = 90
    player_start = copy.deepcopy(player_xy)
    space_to_move_right = (display_width - player_xy[0])/num_frames
    space_to_move_up_down = ((new_xy-player_img_height/2) - player_xy[1])/num_frames
    
    if not exit_right:
        space_to_move_right = space_to_move_right * -1
        space_to_move_up_down = 0
        num_frames = 10
    for i in range(0,num_frames):
        #clear old player
        pygame.draw.rect(gameDisplay,(255,255,255),(player_xy[0],player_xy[1],50,90))
        player_xy[0] = int(player_xy[0] + space_to_move_right)
        player_xy[1] = int(player_xy[1] + space_to_move_up_down)
        gameDisplay.blit(player_image, player_xy)
        #print(player_xy)
        pygame.display.update()
        clock.tick(fps)
    if reset_player_pos:
        player_xy = player_start
    """
def draw_doors():
    global gameDisplay
    global PWD
    
    chroot_PWD = chroot_path + PWD
    #print(chroot_PWD)
    dirs_next_door = []
    dir_pos = {}
    door_color = {}
    try:
        files_and_dirs = os.listdir(chroot_PWD)
    except PermissionError:
        files_and_dirs = []
    for file_or_dir in files_and_dirs:
        file_or_dir = chroot_PWD + "/" + file_or_dir
        if os.path.isdir(file_or_dir):
            if not os.path.islink(file_or_dir):
                #print(file_or_dir)
                if chroot_PWD == "/":
                    short_name = f"/{file_or_dir.split(chroot_PWD)[-1]}"
                elif file_or_dir.startswith(chroot_PWD):
                    short_name = f".{file_or_dir.split(chroot_PWD)[-1]}"
                
                else:
                    short_name = file_or_dir
                dirs_next_door.append(short_name)
    
    #dirs_next_door=["/home","/proc"]
    num_dir_door = len(dirs_next_door)
    #print(num_dir_door)
    
    size_on_right = display_height - 60
    space_per_door = int(size_on_right/(num_dir_door +1))
    #TODO remove this and fix the math
    if num_dir_door == 1:
        offset = -10
    elif num_dir_door > 20:
        offset = 40
    elif num_dir_door > 4:
        offset = 15
    else:
        offset = 0
        
    for i in range(1,num_dir_door+1):
        pos = int((space_per_door*i) + offset)
        dir_pos[dirs_next_door[i-1]] = pos + int(space_per_door/4)
        chroot_sub_path = f"{PWD}/{dirs_next_door[i-1].strip('./')}".replace("//","/")
        full_path = f"{chroot_path}{chroot_sub_path}"
        #check if we can access the folder:
        color = (255,255,255)
        if not os.access(full_path, os.X_OK):
            color = (255,50,50)
        #print(f"Hmmmm {full_path}")
        pygame.draw.rect(gameDisplay,color,(display_width-15,pos,15,int(space_per_door/2)))
        #print(pos)
    for file_name in dir_pos:
        
        #if file_name.startswith(PWD):
            #file_text = f".{file_name.split(PWD)[-1]}"
        #else:
            #file_text = file_name
        TextRect = text_font.render(file_name, True, (0, 0, 0))
        pos = dir_pos[file_name]
        gameDisplay.blit(TextRect, (display_width - (len(file_name)*6),pos - 6))
    return(dir_pos)

            
def process_NPC_line(line):
    global script_path
    global npc_imges
    global game_actors
    global chroot_path
    global PWD
    
    chroot_PWD = chroot_path + PWD
    
    raw_data = line.split(":")
    print(f"Process_NPC_line: {line}")
    #Example data
    #allegiance:star_x:start_y:when:img:name:AI <AI args>:damage:life:% drops
    # bad:  x:  y:    when:          img:             name:     AI:damage:life:    % drops
    #-1  :100:100:on_enter: frog_guy.png:              bob: walk 3:     1:   3: 100% na
    #on_enter: frog_guy.png:              bob: 100% walk 3:     1:  10: 100% na
    #every 40: frog_guy.png: son_of_bob_$RAND: 100% walk 3:     1:  10: 50% 5HP
    allegiance = int(raw_data[0].strip())
    x = raw_data[1].strip()
    y = raw_data[2].strip()
    #try:
    x = int(x)
    y = int(y)
    start_pos = [x,y]
    #except Exception:
        #print("Using random start for NPC")
        #start_pos = [display_width-50,int(display_height/(int(random.randint(1,200)/100)+2))]
    when = raw_data[3].strip()
    name = raw_data[5].strip()
    
    life = int(raw_data[8].strip())
    respawn_data = copy.deepcopy(raw_data)
    
    if "$RAND" in name:
        rand_string = ''.join(random.choices(string.ascii_uppercase + string.digits, k = 7))
        name = name.replace("$RAND", rand_string)
    
    #Used for repeat spawners
    #Correct name in file
    spawn_line_raw = copy.deepcopy(raw_data)
    spawn_line_raw[5] = name
    spawn_line = ":".join(spawn_line_raw)
    spawn_line = spawn_line.replace(when, "on_enter")
    
    #change life:
    respawn_data[8] = "$LIFE"
    respawn_line = ":".join(respawn_data)
    
    
    img = f"{script_path}/img/{raw_data[4].strip()}"
    npc_imges[img] = pygame.image.load(img).convert()
    
    
    AI_raw = raw_data[6].strip().split(' ')
    #Example data
    #walk 3
    AI_args = " ".join(AI_raw[1:])
    AI = AI_raw[0]
    
    damage = int(raw_data[7].strip())
    
    
    life_file = ""
    if when == "on_enter" or when == "active":
        life_file = f"{chroot_PWD}/{name}"
        #with open(life_file, 'w') as fh:
            #pass
        #check for a respawn file
        if os.path.isfile(life_file):
            with open(life_file, 'r') as old_life_fh:
                for line in old_life_fh.readlines():
                    if line.startswith("life:"):
                        life = int(line.split(":")[-1].strip())
                    if line.startswith("respawn:"):
                        os.remove(life_file)
                        old_npc_line = ":".join(line.split(":")[1:])
                        old_npc_line = old_npc_line.replace("$LIFE", str(life))
                        #print(old_npc_line)
                        
                        process_NPC_line(old_npc_line)
                        
                        #print(f"Old guy: {old_npc_line}")
                        return
            
        else:
            write_life_file(life_file, life, respawn_line)
            #set_processed_files(PWD)
            add_processed_file(life_file)
        when = "active"
    drop_raw = raw_data[9].strip().split(' ')
    #Example data
    #["50%", "5HP"]
    #["100%", "na"]
    #["100%", "msg", "str_part", "str_part]
    #['100%', 'open', '/home/poodillion/cave/door2']
    chance_drop = drop_raw[0].strip("%")
    if len(drop_raw) > 2:
        drops = " ".join(drop_raw[1:]).strip()
        #drops = drops.replace("\\n", "\n")
    else:
        drops = drop_raw[1]
    print(f"Setup {drops}")
    
    game_actors[name] = {"when":when,
                            "img":img,
                            "name":name,
                            "AI":AI,
                            "AI_args":AI_args,
                            "start_life": life,
                            "respawn":respawn_line,
                            "spawn_line":spawn_line,
                            "damage":damage,
                            "drop_chance":chance_drop,
                            "drops":drops,
                            "pos":start_pos,
                            "lastPos": copy.deepcopy(start_pos),
                            "life_file": life_file,
                            "allegiance": allegiance}

def load_player_spawners(PWD, load_only=False):
    global chroot_path
    global files_processed
    chroot_PWD = chroot_path + PWD
    #If we have a spawners files load them
    try:
        files_and_dirs = os.listdir(chroot_PWD)
    except PermissionError:
        files_and_dirs = []
    for file_or_dir in files_and_dirs:
        file_or_dir = chroot_PWD + "/" + file_or_dir
        if file_or_dir in files_processed:
            print(f"File already processed: {file_or_dir}")
            continue
        if os.path.isfile(file_or_dir):
            #filter if load_only is set
            if load_only and load_only not in file_or_dir:
                continue
            file_name = file_or_dir
            life = check_for_life(file_name)
            if life:
                respawn = get_respawn(file_name)
                respawn = respawn.replace("$LIFE", str(life))
                #respawn = f"active:{respawn}"
                #example:
                #active:frog_guy.png:frog*: 100% walk 3:     1:   3: 100% na
                respawn_data = respawn.split(":")
                #Update file name
                #respawn_data[2] = file_name.split("/")[-1]
                respawn = ":".join(respawn_data)
                
                is_friend = friendly(file_name)
                print(f"What do you think? friend: {is_friend}")
                #print(f"Potato {load_only}")
                print(respawn)
                process_NPC_line(respawn)


def load_spawners(PWD):
    global chroot_path
    global game_actors
    global npc_imges
    
    chroot_PWD = chroot_path + PWD
    possible_spawn_file = f"{chroot_PWD}/.spawner"
    
    #Clear out any old spawner data
    game_actors = {}
    
    #If we have a spawner load it
    if os.path.isfile(possible_spawn_file):
        with open(possible_spawn_file) as fh:
            for line in fh.readlines():
                if line.startswith("#"):
                    continue
                if "on_enter" in line or "every" in line:
                    print(f"Process NPC spawner: {line}")
                    process_NPC_line(line)
    load_player_spawners(PWD)
        

def draw_npc():
    global game_actors
    global gameDisplay
    global npc_imges
    
    for player_name in game_actors:
        status = game_actors[player_name]['when']
        if status == "active":
            #print("draw NPC")
            img = game_actors[player_name]['img']
            img = npc_imges[img]
            name = game_actors[player_name]['life_file']
            life = check_for_life(name)
            name = name.split("/")[-1]
            name = f"{name}:{life}"
            name_height_offset = int((img.get_height()/2) + 15) * -1
            
            #Clear old
            old_pos = game_actors[player_name]['lastPos']
            old_name_pos = [old_pos[0],old_pos[1]+name_height_offset]
            draw_name(name,old_name_pos, clear=True)
            clear_img(img, old_pos)
            #pygame.draw.rect(gameDisplay,(255,255,255),(pos[0],pos[1],img.get_width(),img.get_height()))
            #Draw new
            pos = game_actors[player_name]['pos']
            name_pos = [pos[0],pos[1]+name_height_offset]
            draw_img(img, pos)
            draw_name(name,name_pos)
            #gameDisplay.blit(img, pos)
            

def did_it_happen(chance):
    chance = int(chance)
    rand_int = random.randint(1,100)
    if rand_int <= chance:
        return(True)
    return(False)

def FIRE(pos, clean_up_and_display=True):
    global gameDisplay
    global player_xy
    fire_pos = [player_xy[0] ,player_xy[1] - 35]
    pygame.draw.line(gameDisplay, (255,0,0), (fire_pos[0], fire_pos[1]), (pos[0], pos[1]), 4)
    pygame.display.update()
    
    if clean_up_and_display:
        clock.tick(fps)
        #Clear line
        pygame.draw.line(gameDisplay, (255,255,255), (fire_pos[0], fire_pos[1]), (pos[0], pos[1]), 4)
    
def update_dynamic_fs():
    global dynamic_fs_levels
    global PWD
    global chroot_path
    global level_data
    global current_level_base
    
    #print(dynamic_fs_levels)
    
    for spawn in dynamic_fs_levels:
        level_data = dynamic_fs_levels[spawn]
        first_dir_path = level_data['spawn']
        max_depth = int(level_data['depth'])
        num_rooms = int(level_data['rooms'])
        all_rooms_npc = level_data['all_rooms_npc']
        #get locked rooms
        locked_rooms = level_data["locked"]
        #print(f"This data: {first_dir_path}")
        start_dir = os.path.dirname(first_dir_path)
        #print(f"This data: {start_dir}")
        if PWD == start_dir:
            #check our start folder is here
            current_level_base = first_dir_path
            full_path = f"{chroot_path}{first_dir_path}"
            if not os.path.isdir(full_path):
                os.mkdir(full_path)
        
        #This is a sub path!
        elif first_dir_path in PWD:
            current_level_base = first_dir_path
            short_path = PWD.split(first_dir_path)[-1]
            depth = len(short_path.split("/"))-1
            
            #setup NPCs
            #Load data example: all_rooms
            for npc_line in all_rooms_npc:
                print(f"Processng NPC line: {npc_line}")
                process_NPC_line(npc_line)
            #Load data example: room:/3
            if short_path in level_data:
                for npc_line in level_data[short_path]:
                    process_NPC_line(npc_line)
            #Load data example: on_path:/1/2
            for level_object in level_data:
                if level_object.startswith("*"):
                    path_to_check = level_object.strip("*")
                    tmp_level_data = level_data[level_object]
                    if path_to_check.startswith(short_path):
                        #print(f"Setting up {level_data}")
                        for line in tmp_level_data:
                            process_NPC_line(line)
            #Load data example: off_path:/1/2
            for level_object in level_data:
                if level_object.startswith("-"):
                    path_to_check = level_object.strip("-")
                    tmp_level_data = level_data[level_object]
                    print(f"DEBUG: {short_path} {path_to_check}")
                    if not path_to_check.startswith(short_path):
                        print(f"Setting up {tmp_level_data}")
                        for line in tmp_level_data:
                            process_NPC_line(line)
                #else:
                    #print(f"Not starting with - {level_object}")
            
            #Build new rooms
            if depth < max_depth:
                #create new rooms if needed
                for room_index in range(1,num_rooms+1):
                    sub_room_name = f"{short_path}/{room_index}"
                    full_path = f"{chroot_path}{first_dir_path}{sub_room_name}"
                    if not os.path.isdir(full_path):
                        os.mkdir(full_path)
                        #print(full_path)
                        #print(short_path)
                        #print(f"HMMM: {sub_room_name} in {locked_rooms}")
                        if sub_room_name in locked_rooms:
                            print(f"Lock away {full_path}")
                            lock_away(full_path)
            #print(f"TODO Yo {depth}")
            print(short_path)
        print(PWD)
        #for level_item in level_data:
            #print(f"{level_item}:{level_data[level_item]}")

#Used for moving along a line at a speed
def get_point_along(point1, point2, speed):
    new_point = copy.deepcopy(point1)
    x_delta = abs(point1[0] - point2[0])
    y_delta = abs(point1[1] - point2[1])
    
    total_delta = x_delta + y_delta
    if total_delta == 0:
        return(point2)
    x_speed = (speed/total_delta)*x_delta
    y_speed = (speed/total_delta)*y_delta
    
    #game_actors[player_name]['lastPos'] = copy.deepcopy(game_actors[player_name]['pos'])
    if point1[0] - point2[0] < 0:
        new_point[0] += x_speed
    else:
        new_point[0] -= x_speed
    
    if point1[1] - point2[1] < 0:
        new_point[1] += y_speed
    else:
        new_point[1] -= y_speed
    
    if abs(new_point[0] - point2[0]) < speed:
        new_point[0] = point2[0]
    if abs(point1[1] - point2[1]) < speed:
        new_point[1] = point2[1]
    
    return(new_point)

def update_game():
    global gameDisplay
    global player_xy
    global game_tick
    global PWD
    global chroot_path
    global player_life
    global game_actors
    global current_level_base
    global display_txt
    global player_target
    global player_speed
    global player_image
    global redraw_forced
    
    decrement_sys_msgs()
    #Move player if needed
    if player_xy != player_target:
        #print(f"Moving player: {player_xy}")
        #clear current pos
        clear_img(player_image, player_xy)
        #pygame.draw.rect(gameDisplay,(255,255,255),(player_xy[0],player_xy[1],player_image.get_width(),player_image.get_height()))
        #update pos
        player_xy_test_point = get_point_along(player_xy, player_target, get_player_speed())
        if can_move_to(player_xy_test_point, player_image):
            player_xy = player_xy_test_point
        #Redraw player
        draw_img(player_image, player_xy)
    
    #Process NPCs
    #print(game_actors)
    new_NPCs = {}
    
    chroot_PWD = chroot_path + PWD
    NPC_lines_to_process = []
    for player_name in game_actors:
        status = game_actors[player_name]['when']
        drop_chance = game_actors[player_name]['drop_chance']
        drops = game_actors[player_name]['drops']
        damage = game_actors[player_name]['damage']
        is_friendly = False
        if status.startswith("every"):
            #print(status)
            start_on = int(status.split(" ")[-1])
            #print(start_on)
            #print(game_tick)
            if game_tick % start_on == 0:
                print("Need to added active!")
                new_npc = copy.deepcopy(game_actors[player_name])
                spawn = new_npc['spawn_line']
                print(f"Process respawn line: {spawn}")
                NPC_lines_to_process.append(spawn)
                #process_NPC_line(spawn)
                """
                print(f"new_npc: {new_npc}")
                new_npc_name = new_npc['name']
                if "$RAND" in new_npc_name:
                    rand_string = ''.join(random.choices(string.ascii_uppercase + string.digits, k = 7))
                    new_npc_name = new_npc_name.replace("$RAND", rand_string)
                
                #setup new life file for NPC
                new_npc['name'] = new_npc_name
                life_file = f"{chroot_PWD}/{new_npc_name}"
                life_value = new_npc['start_life']
                respawn = new_npc['respawn']
                print(f"respawn data: {respawn}")
                write_life_file(life_file, life_value, respawn)
                print(life_file)
                #with open(life_file, 'w') as fh:
                #    pass
                new_npc['when'] = "active"
                new_npc['life_file'] = life_file

                new_NPCs[new_npc_name] = new_npc

                #game_actors[new_npc_name] = new_npc
                #print(game_actors)
                """
                
        if status == "active":
            #print("Active NPC")
            life_file = game_actors[player_name]['life_file']
            allegiance = game_actors[player_name]['allegiance']
            #check if NPC killed
            if not os.path.isfile(life_file):
                print(f"Killed {life_file}| Hmmm:{drop_chance} drops:{drops}")
                if did_it_happen(drop_chance):
                    #examples drops
                    #5HP
                    #unlock/1
                    #msg some string to say
                    if drops.startswith("msg"):
                        msg = drops[3:]
                        write_sys_msg(msg, 65)
                    if drops.endswith("HP"):
                        life_drop = int(drops.strip("HP"))
                        change_life(life_drop)
                        if life_drop > 0:
                            #player_life = player_life + life_drop
                            msg = f"+{life_drop} HP"
                        else:
                            msg = f"-{life_drop} HP"
                        write_sys_msg(msg, 30)
                        print(f"Player life: {player_life}")
                    if drops.startswith("unlock"):
                        short_name = drops.split("unlock")[-1]
                        msg = f"A door has Opened!\nFind your way to:\n  {current_level_base}{short_name}"
                        write_sys_msg(msg, 65)
                        full_path = f"{chroot_path}{current_level_base}{short_name}"
                        print(f"Unlock: {full_path}")
                        unlock_door(full_path)
                    #Like unlock expect takes a full path
                    if drops.startswith("open"):
                        redraw_forced = True
                        path = drops[5:]

                        full_path = f"{chroot_path}{path}"
                        if os.path.isdir(full_path):
                            msg = f"{path} open!"
                            unlock_door(full_path)
                        else:
                            msg = f"Cannot unlock unknown or undiscovered path: \n  {full_path}"
                        write_sys_msg(msg, 65)

                #Setup needed data
                img = game_actors[player_name]['img']
                img = npc_imges[img]
                pos = game_actors[player_name]['pos']
                
                #Draw laser
                clear_img(img, pos, color=(255,0,0))
                #pygame.draw.rect(gameDisplay,(255,0,0),(pos[0],pos[1],img.get_width(),img.get_height()))
                FIRE(pos)
                
                #clear npc
                clear_img(img, pos)
                #pygame.draw.rect(gameDisplay,(255,255,255),(pos[0],pos[1],img.get_width(),img.get_height()))
                game_actors[player_name]['when'] = "DEAD"
                continue
            
            #Check we have an ative attack
            if os.path.isfile(life_file):
                pos = game_actors[player_name]['lastPos']
                with open(life_file) as fh:
                    life_data = fh.readlines()
                for line in life_data:
                    if line.startswith("under_attack:True"):
                        #ative under_attack
                        FIRE(pos, clean_up_and_display=False)
            
            if allegiance > 0:
                target = [200,200]
            else:
                target = player_xy
            pos = game_actors[player_name]['pos']
            AI = game_actors[player_name]['AI']
            AI_args = game_actors[player_name]['AI_args']
            if AI.startswith("msg"):
                msg = f"{player_name}:\n  {AI_args}"
                write_sys_msg(msg, 1)
                #print(f"Writing: {msg}")
            #If this is a walk AI
            if AI.startswith("walk"):
                #If this is a bad NPC
                if allegiance < 0:
                    #check if we are hit
                    if abs(pos[0] - player_xy[0]) < 25 and abs(pos[1] - player_xy[1]) < 25:
                        change_life(damage * -1)
                        #player_life = player_life - damage
                        if get_player_life() <= 0:
                            #Reset
                            print("Player Dead!")
                            text = "Better luck next time!"
                            notify(text)
                            quit()
                        print("Hit")
                        continue
                speed = int(AI_args.strip())
                new_pos = get_point_along(pos, target, speed)
                #x_delta = pos[0] - player_xy[0]
                #y_delta = pos[1] - player_xy[1]
                
                #total_delta = x_delta + y_delta
                #x_speed = (speed/total_delta)*x_delta
                #y_speed = (speed/total_delta)*y_delta
                
                game_actors[player_name]['lastPos'] = copy.deepcopy(game_actors[player_name]['pos'])
                game_actors[player_name]['pos'] = new_pos
                #print(f"Moving with speed of {speed} {x_speed} {y_speed}")
                
            #print(pos)
    #add new NPCs outside of above eath loop
    #print(f"Needs added: {NPC_lines_to_process}")
    for npc_line in NPC_lines_to_process:
        process_NPC_line(npc_line)
    #mark files as known about
    if NPC_lines_to_process != []:
        set_processed_files(PWD)
    #for new_npc_name in new_NPCs:
        #game_actors[new_npc_name] = new_NPCs[new_npc_name]


#get changed files and add them to files_processed
def get_changed_files(PWD):
    global files_processed
    
    needs_processed = []
    chroot_PWD = chroot_path + PWD
    try:
        files_and_dirs = os.listdir(chroot_PWD)
    except PermissionError:
        files_and_dirs = []
    for file_or_dir in files_and_dirs:
        file_or_dir = chroot_PWD + "/" + file_or_dir
        if os.path.isfile(file_or_dir):
            if file_or_dir not in files_processed:
                needs_processed.append(file_or_dir)
    files_processed = files_processed + needs_processed
    return(needs_processed)


def add_processed_file(file_name):
    global files_processed
    files_processed.append(file_name)

#Add all PWD to files_processed
def set_processed_files(PWD):
    global files_processed
    files_processed = []
    
    chroot_PWD = chroot_path + PWD
    try:
        files_and_dirs = os.listdir(chroot_PWD)
    except PermissionError:
        files_and_dirs = []
    for file_or_dir in files_and_dirs:
        file_or_dir = chroot_PWD + "/" + file_or_dir
        if os.path.isfile(file_or_dir):
            files_processed.append(file_or_dir)


def main_interface():
    #Globals needed by the reset call
    global selected_crop
    global text_font
    global background_color
    global player_image
    global player_xy
    global PWD
    global game_actors
    global game_tick
    global player_life
    global player_power
    global redraw_forced
    global std_out
    global prompt_text
    global view_tty
    global player_speed
    global player_target
    global player_start_pos
    global files_processed
    global pre_game
    
    running = True
    
    background_color = pygame.color.Color(25,25,25)
    prompt_text = prompt_raw
    std_out = ""
    num_dir_door = 0
    player_start_pos = [50, int(display_height/2)-45]
    player_xy = copy.deepcopy(player_start_pos)
    player_target = player_xy
    player_speed = get_player_speed()
    player_image = pygame.image.load(f"{script_path}/img/player.png").convert()
    dir_pos = {}
    game_actors = {}
    game_tick = 1
    redraw_forced = False
    view_tty = False
    pre_game = True
    

    #img = pygame.image.load(image_file_to_display)
    #img = pygame.transform.scale(img, (display_width, display_height))
    

    PWD = get_PWD()
    rendered_path = None

    while running:
        #look for new events
        for event in pygame.event.get():
            #print(event)
            if event.type == pygame.QUIT:
                pygame.quit()
                quit()
            if event.type == pygame.KEYDOWN:
                key = event.unicode
                keys = pygame.key.get_pressed()
                arrow_pressed = False
                
                if not pre_game:
                    # if left arrow key is pressed 
                    if keys[pygame.K_LEFT]:
                        player_target[0] = 0
                        arrow_pressed = True
                
                    # if left arrow key is pressed
                    if keys[pygame.K_RIGHT]:
                        player_target[0] = display_width
                        arrow_pressed = True
                
                    # if left arrow key is pressed
                    if keys[pygame.K_UP]:
                        player_target[1] = 0
                        arrow_pressed = True
                
                    # if left arrow key is pressed
                    if keys[pygame.K_DOWN] :
                        player_target[1] = display_height
                        arrow_pressed = True
                
                #Pass into TTY
                if not arrow_pressed:
                    composit_process(key)
                    #print(key)
                    #Update prompt and std_out
                    time.sleep(0.01)
                    std_raw = get_tty_out()
                    prompt_text = std_raw[0]
                    std_out = std_raw[1]
                    #print(std_out)
                    #Update PWD
                    PWD = get_PWD()
                    #print(PWD)
                    draw_prompt(prompt_text)


        #redraw room
        if (rendered_path != PWD or redraw_forced) and PWD != "Loading...":
            ######################################################
            ########Updates on PWD change or redraw_forced########
            ######################################################
            #Play cd action
            if not redraw_forced:
                #player_xy = copy.deepcopy(player_start_pos)
                #player_target = copy.deepcopy(player_start_pos)
                files_processed = []
                
                short_pwd = f"./{PWD.split('/')[-1]}"
                if short_pwd in dir_pos:
                    action_cd([display_width,dir_pos[short_pwd]])
                elif rendered_path != None:
                    action_cd([0,display_height/2])
            
            #Update rendered path
            rendered_path = PWD
            
            #Clear
            gameDisplay.fill(background_color)
            
            #draw main room
            pygame.draw.rect(gameDisplay,(255,255,255),(15,15,display_width-30,display_height-30))
            draw_prompt(prompt_text)
            
            #draw player
            draw_img(player_image, player_xy)
            
            #draw map
            pos = 30
            width_offset = display_width - (len(PWD)*5) - 35
            #pygame.draw.rect(gameDisplay,(255,0,0),(0,pos,15,30))
            TextRect = text_font.render(PWD, True, (0, 0, 0))
            gameDisplay.blit(TextRect,(width_offset,pos))
            
            #Draw ../ door
            if PWD != "/":
                pos = int(display_height/2)
                pygame.draw.rect(gameDisplay,(255,255,255),(0,pos,15,30))
                TextRect = text_font.render("../", True, (0, 0, 0))
                gameDisplay.blit(TextRect,(10,pos+8))
            
            
            #Don't update logic if redraw if forced
            if not redraw_forced or pre_game:
                #End pre_game
                pre_game = False
                
                #load spawner
                load_spawners(PWD)
                set_processed_files(PWD)
                
                #Update dynamic_fs
                update_dynamic_fs()
            else:
                redraw_forced = False
            #Draw dirs in room as doors
            dir_pos = draw_doors()
        ######################################################
        #################Updates every Tick###################
        ######################################################
        #Draw life bar:
        #clear old
        pygame.draw.rect(gameDisplay,(255,255,255),(20,20,100,10))
        #Draw new
        value_bar(20,20, get_player_life(), from_right=False, size=10, px_multiplayer=1, hide_text=False, title="Life")
        
        
        #Check set_processed_files
        if PWD != "Loading...":
            for new_file in get_changed_files(PWD):
                print(f"New file found {new_file}")
                load_player_spawners(PWD, load_only=new_file)
        
        #Draw Power bar
        pos = display_width-125
        pygame.draw.rect(gameDisplay,(255,255,255),(pos,20,100,10))
        #Draw new
        value_bar(pos,20, get_player_power(), from_right=False, size=10, px_multiplayer=1, hide_text=False, title="Power")
        player_power
        
        
        
        #If in draw tty mode:
        if view_tty:
            std_raw = get_tty_out()
            prompt_text = std_raw[0]
            std_out = std_raw[1]
            std_out_tmp = ""
            for line in std_out:
                if line.strip() != "":
                    std_out_tmp = std_out_tmp + line + "\n"
            std_out_tmp = f"{std_out_tmp}{prompt_text}"
            write_sys_msg(std_out_tmp, 1)
        
        #Update display text:
        msg_offset = -15
        current_msg = get_sys_msg()
        if current_msg == {} and display_txt != "":
            print("Redraw room for text change")
            display_txt = ""
            redraw_forced = True

        for message in current_msg:
            msg_offset = msg_offset + 15
            ticks_left = get_sys_msg_ticks(message)
            
            #display_txt[message] = display_txt[message] - 1
            #clear
            pos = [25,45+msg_offset]
            for line in message.split("\n"):
                pygame.draw.rect(gameDisplay,background_color,(pos[0]-5,pos[1]-5,display_width -pos[0]*2 ,20))
                #Draw
                TextRect = text_font.render(line, True, (255, 255, 255))
                gameDisplay.blit(TextRect, (pos[0],pos[1]))
                #print(f"{message}:{ticks_left}")
                pos[1] += 15
            display_txt = current_msg

            
        
        #Draw STD view button
        std_button_pos = [display_width - 55,display_height - 50]
        std_button_size = [35,30]
        view_tty = False
        button("TTY",std_button_pos[0],std_button_pos[1],std_button_size[0],std_button_size[1],(0,0,255),view_tty_set_true)
        
        
        #Process move click/tap
        mouse_pos = pygame.mouse.get_pos()
        click = pygame.mouse.get_pressed()
        #if tap down
        if click[0] == 1 and not pre_game:
            x,y = mouse_pos
            player_target = [x,y]
            #print(player_target)
        #button("",sidebar_pos[0],sidebar_pos[1],20,300,lockdown_color,quit)
        
        
        #Draw keyboard info
        #keyboard_text = "(EN) Keybaord"
        #keyboard_pos = [display_width- 100,590]
        #keyboard_size = [int(display_width/3.5),70]
        #button(keyboard_text,keyboard_pos[0],keyboard_pos[1],keyboard_size[0],keyboard_size[1],color,quit)
        
        #############################################################################################
        #Draw is powered bar
        #############################################################################################
        #power_bar_pos = [display_width/2-13,577]
        #button("",power_bar_pos[0],power_bar_pos[1],25,75,powered_bar_color,quit)
        #Update NPC
        update_game()
        #Draw NPC
        draw_npc()
        if game_tick > 1000:
            game_tick = 2
        else:
            game_tick = game_tick + 1
        #print(game_tick)
        #print("Tick")
        pygame.display.update()
        clock.tick(fps)

def view_tty_set_true():
    global view_tty
    global player_power
    global pre_game
    
    if pre_game:
        view_tty = True
        return
    
    cost = 1
    if get_player_power() >= cost:
        change_power(cost * -1)
        view_tty = True


#place holder button function
def blank():
    print("Blank")
    return()

def cmd_run(command):
    command = command.split()
    try:
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        raw_data =  result.stdout.decode()
        raw_data += result.stderr.decode()
    except FileNotFoundError:
        raw_data = "Command Not Found"
    
    return(raw_data)

def cmd_live(command):
    process = subprocess.Popen(command, stdout=subprocess.PIPE)
    for line in iter(process.stdout.readline, b''):
        yield(line)
        
def notify(msg):
    cmd = f"notify-send Poodillion '{msg}'"
    os.system(cmd)

#Install/build root
def run_setup():
    cmd = f"/usr/bin/pkexec '{script_path}/bin/build_root.sh'"
    msg = "Running setup for the first time... \nThis will take about 10 minutes"
    notify(msg)
    print(msg)
    os.system(cmd)


def load_dynamic():
    global dynamic_fs_levels
    global script_path
    
    path = f'{script_path}/dynamic_fs/'

    files = os.listdir(path)
    
    level_files = []
    for file_name in files:
        level_path = f"{path}{file_name}"
        #print(level_path)
        level_files.append(level_path)
    

    for level_path in level_files:
        level_data = {}
        level_data["locked"] = []
        level_data["all_rooms_npc"] = []
        raw_data = open(level_path).readlines()
        name = ""
        for level_line in raw_data:
            if level_line.startswith("#"):
                continue
            for easy_load_team in ["spawn", "rooms", "depth"]:
                if level_line.startswith(easy_load_team):
                    level_data[easy_load_team] = level_line.split(":")[-1].strip()
            if level_line.startswith("locked:"):
                level_data["locked"].append(level_line.split(":")[-1].strip())
            if level_line.startswith("all_rooms:"):
                data = level_line.split("all_rooms:")[-1].strip()
                level_data["all_rooms_npc"].append(data)
            if level_line.startswith("room:"):
                data = level_line.split(":")
                room_path = data[1]
                spawn_data = level_line.split(f"room:{room_path}:")[-1].strip()
                if room_path not in level_data:
                    level_data[room_path] = [spawn_data]
                else:
                    level_data[room_path].append(data)
            if level_line.startswith("on_path:"):
                #Example data
                #all on path:     when:           img:     name:    %  action:damage:life:   % drops
                #on_path:/1/2:on_enter: ball_boss.png: the_lost: 100% walk 10:     7:  10: 70% msg Yo. 

                data = level_line.split(":")
                room_path = f"*{data[1]}"
                spawn_data = ":".join(data[2:]).strip()
                if room_path not in level_data:
                    level_data[room_path] = [spawn_data]
                else:
                    level_data[room_path].append(data)
            
            if level_line.startswith("off_path:"):
                #Example data
                #all on path:     when:           img:     name:    %  action:damage:life:   % drops
                #on_path:/1/2:on_enter: ball_boss.png: the_lost: 100% walk 10:     7:  10: 70% msg Yo. 

                data = level_line.split(":")
                bad_room_path = f"-{data[1]}"
                spawn_data = ":".join(data[2:]).strip()
                if bad_room_path not in level_data:
                    level_data[bad_room_path] = [spawn_data]
                else:
                    level_data[bad_room_path].append(data)
        name = level_data["spawn"]
        dynamic_fs_levels[name] = level_data
        
############################################### 
setup_sys()

#setup init msg
write_sys_msg(init_text, 50)
###############################################
#Load in fs level data effects dynamic_fs_levels
load_dynamic()
#for spawn in dynamic_fs_levels:
#    level_data = dynamic_fs_levels[spawn]
#    for level_item in level_data:
#        print(f"{level_item}:{level_data[level_item]}")
#print(dynamic_fs_levels)

#Setup tty
###############################################
#Open new virt tty shell
open_tty()

def get_PWD():
    global BASH_PID
    global chroot_path
    global script_path
    path = f"{chroot_path}/game/PWD"
    if not os.path.isfile(path):
        #This should only happen if the main chroot is missing.
        print("Need to run setup script!")
        run_setup()
        
    with open(path) as fh:
        return_data  = fh.readline().strip()
    return(return_data)

def get_tty_out():
    try:
        raw_data = copy.deepcopy(output_data[target_tty])
    except RuntimeError as E:
        #retry
        print("Error reading data...")
        time.sleep(.02)
        print(E)
        return(get_tty_out())

    cmd_text = ""
    shell_prompt = ""
    for line_index in raw_data:
        line = raw_data[line_index]
        cmd_text = cmd_text + "\n"
        for col_index in line:
            char_obj = line[col_index]
            char_pos = [line_index, col_index]
            cmd_text = cmd_text + char_obj.data
    shell_prompt = cmd_text.split("\n")[-1].strip()
    std_out = cmd_text.split("\n")[:-1]
    #print(f"New shell: {cmd_text}")
    #print(cmd_text)
    #return("")
    return([shell_prompt,std_out])

#get_PWD has a check if the chroot is setup
PWD_ATM = get_PWD()
#Make sure to start in /home/poodillion
if PWD_ATM != "Loading...":
    path = f"{chroot_path}/game/PWD"
    with open(path, 'w') as fh:
        fh.write("Loading...")
###############################################
#Run Init bash comand
msg = "Poodillion needs root access to isolate itself in a systemd container."
notify(msg)
bash_run(startup_CMD, -1)
#Set prompt
cmd = f'PS1="{prompt_raw}"'
bash_run(cmd, -1)
###############################################
pygame.init()
text_font = pygame.font.SysFont("comicsansms",fount_size)
gameDisplay = pygame.display.set_mode((display_width,display_height))
main_interface()
